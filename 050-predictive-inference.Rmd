```{r ch050-setup, include=FALSE}
library(tidyverse)
library(rethinking)
library(loo)

l031_av   <- loo(readRDS("models/m031.rds"))
l032_av   <- loo(readRDS("models/m032.rds"))
l032nc_av <- loo(readRDS("models/m032nc.rds"))
l033_av   <- loo(readRDS("models/m033.rds"))
l033_vis  <- loo(readRDS("models/m033vis.rds"))
l034_vis  <- loo(readRDS("models/m034vis.rds"))
l034s_vis <- loo(readRDS("models/m034s_vis.rds"))
```

# Predictive Inference {#predictive-inferences}

_All models are wrong, but some are useful_

The above quote is from George Box, and it is a popular quote that statisticians like to throw around^[I am one of them]. All models are wrong because it is nearly impossible to account for the minutiae of every process that contributes to an observed phenomenon, and often trying to results in poorer performing models. Also is it ever truly possible to _prove_ that a model is correct? At best our scientific method can falsify certain hypotheses, but it cannot ever tell us if a model is universally correct. That doesn't matter. What does matter is if the model is useful and can make accurate predictions.

Why is predictive performance so important? Consider five points of data (figure \@ref(fig:ch050-Moving-Moose)). I have simulated values from some polynomial equation of degree less than five, but with no more information other than that, how can the best polynomial model be selected?

```{r ch050-Moving-Moose, fig.cap="Five points from a polynomial model."}
set.seed(11)
x0 <- 0:5
y0 <- -0.5*(x0 - 2)^2 + 2 + rnorm(length(x0), 0, 1)
x <- head(x0, 5)
y <- head(y0, 5)
p <- ggplot(data.frame(x=x, y=y), aes(x, y)) + 
  geom_point(size = 4)
p
```

One thing to try is fit a handful of linear models, check the parameter's p-values, the $R^2$ statistic, and perform other goodness of fit tests, but there is a problem. As you increase the degree of the polynomial fit, the $R^2$ statistic will always increase. In fact with five data points, a fourth degree polynomial will fit the data perfectly (figure \@ref(fig:ch050-Olive-Screwdriver)).


```{r ch050-Olive-Screwdriver, fig.cap="Data points with various polynomial regression lines."}
p2 <- p +
  geom_smooth(formula = y ~ 1 + x, 
              method = "lm", se = FALSE,
              aes(color = "Linear")) +
  geom_smooth(formula = y ~ 1 + x + I(x^2), 
              method = "lm", se = FALSE,
              aes(color = "Quadratic")) +
  geom_smooth(formula = y ~ 1 + x + I(x^2) + I(x^3), 
              method = "lm", se = FALSE,
              aes(color = "Cubic")) +
  geom_smooth(formula = y ~ 1 + x + I(x^2) + I(x^3) + I(x^4), 
              method = "lm", se = FALSE,
              aes(color = "Quartic")) +
  geom_point(size = 4) +
  scale_color_manual(values = c("#20639B",
                                "#3CAEA3",
                                "#F6D55C",
                                "#ED553B"),
                     limits = c("Linear",
                                "Quadratic",
                                "Cubic",
                                "Quartic"),
                     labels = c("Linear",
                                "Quadratic",
                                "Cubic",
                                "Quartic"),
                     name = "Degree")
p2
```

If I were to add a $6^{th}$ point - a new observation - which of the models would you expect to do best? Can it be estimated which model will predict best before testing with new data? One guess is that the quadratic or cubic model will do well because because the linear model is potentially _underfit_ to the data and the quartic is _overfit_ to the data. Figure \@ref(fig:ch050-Cold-Fish) shows the new data point from the polynomial model. Now the linear and cubic models are trending in the wrong direction. The quadratic and quartic models are both trending down, so may be the correct form for the model.


```{r ch050-Cold-Fish, fig.cap="The fitted polynomial models with a new observation."}
p2 + 
  geom_point(data = data.frame(x = tail(x0, 1), y = tail(y0, 1)),
             shape = 17, size = 4)
```

Figure \@ref(fig:ch050-Strawberry-Swallow) shows the 80% and 95% prediction intervals for a new observation given $x = 5$ as well as the true outcome as a dashed line at $y = `r round(tail(y0, 1), 3)`$. The linear model has the smallest prediction interval (PI), but completely misses the target. The remaining three models all include the observed value in their 95% PIs, but the quadratic has the smallest PI of the three. The actual data generating polynomial is

$$
y \sim \mathcal{N}(\mu, 1^2) \\
\mu = -0.5(x - 2)^2 + 2
$$


```{r ch050-Maximum Panther, include=FALSE}
d <- data.frame(y = y,
          x = x,
          x2 = x^2,
          x3 = x^3,
          x4 = x^4)

m1 <- xfun::cache_rds({
  ulam(alist(
    y ~ dnorm(mu, sigma),
    mu <- a + b1*x,
    c(a, b1) ~ dnorm(0, 2),
    sigma ~ dexp(1)
  ), data = d, log_lik=TRUE)
})
m2 <- xfun::cache_rds({
  ulam(alist(
    y ~ dnorm(mu, sigma),
    mu <- a + b1*x + b2*x2,
    c(a, b1, b2) ~ dnorm(0, 2),
    sigma ~ dexp(1)
  ), data = d, log_lik=TRUE)
})
m3 <- xfun::cache_rds({
  ulam(alist(
    y ~ dnorm(mu, sigma),
    mu <- a + b1*x + b2*x2 + b3*x3,
    c(a, b1, b2, b3) ~ dnorm(0, 2),
    sigma ~ dexp(1)
  ), data = d, log_lik=TRUE)
})
m4 <- xfun::cache_rds({
  ulam(alist(
    y ~ dnorm(mu, sigma),
    mu <- a + b1*x + b2*x2 + b3*x3 + b4*x4,
    c(a, b1, b2, b3, b4) ~ dnorm(0, 2),
    sigma ~ dexp(1)
  ), data = d, log_lik=TRUE)
})
```


```{r ch050-Strawberry-Swallow, fig.cap="95% Prediction intervals for the four polynomial models, as well as the true value (dashed line)."}
new_y <- tail(y0, 1)
new_x <- tail(x0, 1)
new_dat <- data.frame(x  = new_x,
                      x2 = new_x^2,
                      x3 = new_x^3,
                      x4 = new_x^4)
bind_rows(
  round(PI(link(m1, data = new_dat), prob = c(0.8, 0.95)), 3),
  round(PI(link(m2, data = new_dat), prob = c(0.8, 0.95)), 3),
  round(PI(link(m3, data = new_dat), prob = c(0.8, 0.95)), 3),
  round(PI(link(m4, data = new_dat), prob = c(0.8, 0.95)), 3)
) %>%
  add_column(model = c("Linear", "Quadratic", "Cubic", "Quartic"), 
             .before = 1) %>%
  mutate(model = factor(model, 
                        levels = c("Linear", "Quadratic", "Cubic", "Quartic"))) %>%
  ggplot(aes(x = model, xend = model, y = `3%`, yend = `98%`)) +
  geom_segment(size = 1, color = "gray30") +
  geom_segment(aes(x = model, xend = model, y = `10%`, yend = `90%`), 
               size = 2, inherit.aes = FALSE) +
  geom_hline(yintercept = new_y, linetype = "dashed") +
  labs(y = "Prediction Interval", x = "Model",
       title = "Predicting a new Observation",
       subtitle = "x = 5, 80% and 95% Prediction Intervals")
```

This is just a toy example, and real-world real-data models are often more complex, but they do present the same headaches when it comes to model/feature selection and goodness of fit checks. Clearly the quartic model has the best fit to the data, but it is too variable and doesn't capture the regular features of the data, so it does poorly for the out-of-sample prediction. The linear model suffers as well by being less biased and too inflexible to capture the structure of the data. The quadratic and cubic are in the middle of the road, but the quadratic does well and makes fewer assumptions about the data. In other words, the quadratic model is just complex enough to predict well while making fewer assumptions. _Information criteria_ is a way of weighing the prediction quality of a model against its complexity, and is arguably a better system for model selection/comparison than other goodness of fit statistics such as $R^2$ or p-values.

## Model Comparison via Predictive Performance

We don't always have the observed data to compare predictions against (nor the data generating model). Some techniques to compensate for this limitation include cross validation, where the data is split into _training_ data and _testing_ data. The model is fit to the training data, and then predictions are made with the testing data and compared to the observed values. This can often give a good estimate for out-of-sample prediction error. Cross validation can be extended into k-fold cross validation. The idea is to _fold_ the data into $k$ disjoint partitions, and predict partition $i$ using the rest of the data to train on. The prediction error of the $k$-folds can then be averaged over to get an estimate for out-of-sample prediction error.

Taking $k$-fold CV to the limit by letting $k = \# observations$ results in something called _leave one out cross validation_ (LOOCV), where for each observation in the data, the model is fit to the remaining data and predicted for the left out observation. The downside of $k$-fold cross validation is that it requires fitting the model $k$ times, which can be computationally expensive for complex Bayesian models. Thankfully there is a way to approximate LOOCV without having to refit the model many times.

### LOOCV and Importance Sampling

LOOCV and many other evaluation tools such as WAIC rest on the _log-pointwise-predictive-density_ (lppd), which is a loose measure of deviance from some "true" probability distribution. Typically we don't have the analytic form of the predictive posterior, so instead we use $S$ MCMC draws to approximate the lppd [@vehtari2017practical]:

$$
\begin{equation}
\mathrm{lppd}(y, \Theta) = \sum_i \log \frac{1}{S} \sum_s p(y_i | \Theta_s)
(\#eq:lppd)
\end{equation}
$$

To estimate LOOCV, the relative "importance" of each observation must be computed. Certain observations have more influence on the posterior distribution, and so have more impact on the posterior if they are removed. The intuition behind measuring importance is that more influential observations are relatively less likely than less important observations that are relatively expected. Then by omitting a sample, the relative importance weight can be measured by the lppd. This omitted calculation is known as the out-of-sample lppd. For each omitted $y_i$,

$$
\mathrm{lppd}_{CV} = \sum_i \frac{1}{S} \sum_s \log p(y_{i} | \Theta_{-i,s})
$$


















There is a package called `loo` that can compute the expected log-pointwise-posterior-density (ELPD) using PSIS-LOO, as well as the estimated number of effective parameters and LOO information criterion [@R-loo]. For the part of the researcher, the log-likelihood of the observations must be computed in the model. For my models, I added this in the _generated quantities_ block of my Stan program. It is standard practice to name the log-likelihood as `log_lik` in the model.

```
generated quantities {
  vector[N] log_lik;

  for (i in 1:N) {
    real alpha = b + bGT[G[i], trt[i]];
    real beta = a + aGT[G[i], trt[i]];
    real lambda = lG[G[i]];
    real p = lambda + (1 - 2*lambda) * inv_logit(exp(beta) * (x[i] - alpha));
    log_lik[i] = binomial_lpmf(k[i] | n[i], p);
  }
}
```

 Models can be compared simply using `loo::loo_compare`. It estimated the ELPD and its standard error, then calculates the relative differences between all the models. The model with the highest ELPD is predicted to have the best out-of-sample predictions. The comparison of the first three iterations of the model from [chapter 3](#workflow) for the audiovisual data are shown below.

```{r ch050-Artificial Bleeding, echo=TRUE}
comp_av <- loo_compare(l031_av, l032_av, l032nc_av, l033_av)
print(comp_av, simplify = FALSE)
```

The centered and non-centered parameterizations (models 2 and 3 respectively) have essentially the same ELPD. This is expected since they are essentially the same model. The reparameterization only helps with model fitting efficiency, though that can mean more reliable posteriors. The model with age-block interactions (model 4) has the highest ELPD, but is not decisively the best as determined by the standard error of the ELPD. The only thing that can be determined is that including age and block improves performance significantly over the base model (model 1).

But how about for the visual data? The fourth iteration of the model introduced a lapse rate. Did the change significantly improve the ELPD?

```{r ch050-Full Shower, echo=TRUE}
comp_vis <- loo_compare(l033_vis, l034_vis)
print(comp_vis, simplify = FALSE)
```

Absolutely! Something else interesting also happened with the introduction of the lapse rate - the effective number of parameters decreased (`p_loo`).

Earlier I argued that model selection is out, model comparison is in. At the end of [chapter 3](#workflow) I finished with a model that has age-block interactions and a lapse rate for each age group. There was one more model that I could have specified - one that estimates at the subject level. There is no domain-specific reason to include the subject level information, especially since the goal is to make inferences at the age group level, but there may still be statistical reason to add in the subjects. For one, adding in the subject as another level in a multilevel model can induce regularization among the subjects, which can overall make for better predictions on new data.

I've gone ahead and fit the model with subject-level information, and the comparison between this new model and the one from iteration 4 is shown below.

```{r ch050-Skilled Weeknight, echo=TRUE}
comp_vis2 <- loo_compare(l034_vis, l034s_vis)
print(comp_vis2, simplify = FALSE)
```

Including the subject-level information significantly improves the ELPD, and even though there are over 100 parameters in the model (slope and intercept for each of the 45 subjects), the effective number of parameters is much less. Since this new model is capable of making inferences at both the age group level and the subject level, I use it for the result section ([chapter 6](#results)).

One concern comes up when it comes to LOOCV and multilevel models. What does it mean to leave _one_ out? Should one subject be left out? One age group? Just one observation? With more levels in a model, more careful considerations must be taken when it comes to estimating prediction performance.
